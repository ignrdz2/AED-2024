1. 

El algoritmo de Quicksort se basa en el principio de "divide y vencer치s". Durante su ejecuci칩n, se mantiene la siguiente condici칩n en todo momento:

Condici칩n del Quicksort
En cada paso del algoritmo, los elementos del arreglo se dividen en dos subarreglos alrededor de un pivote, de manera que:
- Todos los elementos en el subarreglo izquierdo son menores o iguales al pivote.
- Todos los elementos en el subarreglo derecho son mayores o iguales al pivote.
Esta partici칩n asegura que el pivote est칠 en su posici칩n final correcta en el arreglo ordenado. Luego, el algoritmo se aplica recursivamente a los dos subarreglos hasta que cada subarreglo contiene uno o cero elementos, momento en el cual todo el arreglo est치 ordenado. Esta propiedad se cumple en cada nivel de la recursi칩n, garantizando la correcta ordenaci칩n del conjunto de datos.

ejercicio 3

El art칤culo en DZone discute el quicksort de doble pivote utilizado en el m칠todo Arrays.sort de Java, esta versi칩n mejora el rendimiento para arrays grandes utilizando dos pivotes en lugar de uno. Los puntos clave son:
Rendimiento de datos aleatorios: El quicksort de doble pivote es m치s r치pido que el quicksort b치sico y el de tres pivotes. 
Rendimiento de datos duplicados: El quicksort de doble pivote supera significativamente a los dem치s, especialmente con duplicados.
Estabilidad: El quicksort de doble pivote no es estable; no preserva el orden relativo de los elementos iguales. 
Complejidad: La complejidad temporal sigue siendo 洧녝 ( 洧녵 log  洧녵 ) O(nlogn) para casos medios, pero en el peor de los casos puede degradarse a 洧녝 ( 洧녵 2 ) O(n 2 ) sin precauciones.

ejercicio 4
 An치lisis Detallado del Orden del Tiempo de Ejecuci칩n de Quicksort

1. Peor Caso del Quicksort:
El peor caso ocurre cuando el pivote seleccionado es siempre el menor o el mayor elemento del subconjunto a ordenar. Esto provoca que la partici칩n divida el conjunto en dos partes extremadamente desiguales (una vac칤a y otra con el resto de los elementos). En este caso, el tiempo de ejecuci칩n del algoritmo se degrada a (O(n^2)).

2. Probabilidad del Peor Caso:
Si las posiciones de las claves tienen una distribuci칩n uniforme, la probabilidad de seleccionar siempre el peor pivote es muy baja. En cada partici칩n, el peor caso solo se da si el pivote es el elemento m치s grande o el m치s peque침o, lo cual tiene una probabilidad de (2/n) en cada paso. Para que esto ocurra en todas las (n) particiones, la probabilidad ser칤a extremadamente baja ((2/n)^n)).

3. Mejora del Algoritmo para Conjuntos Peque침os:
Para mejorar la eficiencia en conjuntos peque침os, el algoritmo Quicksort puede cambiar a un m칠todo de ordenaci칩n m치s sencillo como la ordenaci칩n por inserci칩n. Esto se hace t칤picamente cuando el tama침o del subconjunto es menor que un umbral definido (por ejemplo, 10 o 20 elementos).

Modificaci칩n del Algoritmo:

public static void quicksort(int[] arr, int low, int high) {
    if (high - low < 10) {
        insertionSort(arr, low, high);
    } else {
        int pivotIndex = partition(arr, low, high);
        quicksort(arr, low, pivotIndex - 1);
        quicksort(arr, pivotIndex + 1, high);
    }
}

private static void insertionSort(int[] arr, int low, int high) {
    for (int i = low + 1; i <= high; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= low && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
